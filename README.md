# OOPs

## Content Structure

```
OOP (Object Oriented Programming)
│
├── Class & Object
│   ├── Data Members & Member Functions
│   └── Access Specifiers
│       ├── Public
│       ├── Private
│       └── Protected
│
├── Encapsulation
│   ├── Data Hiding
│   └── Getters & Setters
│
├── Constructor
│   ├── Default Constructor
│   ├── Parameterized Constructor
│   ├── Copy Constructor
│   │   ├── Shallow Copy
│   │   └── Deep Copy
│   ├── this Pointer
│   └── Destructor
│
├── Inheritance
│   ├── Mode of Inheritance
│   │   ├── Public
│   │   ├── Private
│   │   └── Protected
│   └── Types of Inheritance
│       ├── Single
│       ├── Multilevel
│       ├── Multiple
│       ├── Hierarchical
│       ├── Hybrid
│       └── Multipath (Diamond Problem)
│
├── Polymorphism
│   ├── Compile-time Polymorphism
│   │   ├── Function Overloading
│   │   └── Operator Overloading
│   └── Runtime Polymorphism
│       ├── Function Overriding
│       └── Virtual Function
│
├── Abstraction
│   ├── Abstract Class
│   └── Pure Virtual Function
│
└── Static Keyword
    ├── Static Data Members
    ├── Static Member Functions
    └── Class-level Shared Memory
    
├── Friend Concept
│   ├── Friend Function
│   └── Friend Class
│
├── Templates
│   ├── Function Template
│   └── Class Template
│
├── Exception Handling
│   ├── try / catch / throw
│   └── Custom Exception
│
├── Namespace
│   └── Custom Namespace / std Namespace
│
├── Composition & Aggregation
│   ├── Has-A Relationship
│   └── Lifetime Dependency
│
└── Advanced Concepts
    ├── Dynamic Binding (vtable & vptr)
    └── Object Slicing
```

```
Object-Oriented Programming (OOP)
│
├── Introduction
│   ├── What is OOP and why it is needed
│   ├── OOP vs Procedural Programming
│   ├── Real-world analogy of OOP
│   ├── Class vs Object
│   └── OOP in different languages (Python, C++, Java, etc.)
│
├── Core Pillars of OOP
│   ├── Encapsulation
│   ├── Abstraction
│   ├── Inheritance
│   └── Polymorphism
│
├── Class Fundamentals
│   ├── Class definition & syntax
│   ├── Attributes (variables) → instance vs class variables
│   ├── Methods → instance, class method, static method
│   ├── Access modifiers (public, protected, private variants)
│   ├── Constructor → initialization
│   └── Destructor
│
├── Objects & Memory Model
│   ├── Creating objects
│   ├── Self / this pointer
│   ├── Object lifetime & scope
│   ├── Object reference vs value copy
│   └── Memory allocation for objects
│
├── Encapsulation Deep Dive
│   ├── Private attributes & name mangling
│   ├── Getters & Setters
│   ├── Properties
│   └── Information hiding vs data protection
│
├── Abstraction Deep Dive
│   ├── Abstract classes & methods
│   ├── Interfaces
│   ├── Multiple interfaces
│   ├── Abstract base classes (ABC)
│   └── Partial abstraction vs full abstraction
│
├── Inheritance Deep Dive
│   ├── Single inheritance
│   ├── Multilevel inheritance
│   ├── Multiple inheritance
│   ├── Hierarchical inheritance
│   ├── Hybrid inheritance
│   ├── Super / Base calls
│   ├── Method Resolution Order (MRO)
│   └── Diamond problem & solutions
│
├── Polymorphism Deep Dive
│   ├── Compile-time vs Runtime polymorphism (conceptual)
│   ├── Method overloading
│   ├── Method overriding
│   ├── Operator overloading
│   ├── Duck typing (Python-style)
│   └── Dynamic dispatch
│
├── Object Relationships (OOP Architecture)
│   ├── Association
│   ├── Aggregation
│   ├── Composition
│   ├── Dependency (uses-a relationship)
│   └── Identifying correct relationship in design
│
├── Unified Modeling Tools (Design Thinking)
│   ├── Class diagrams
│   ├── Object diagrams
│   ├── Sequence diagrams
│   └── UML notations for OOP modeling
│
├── Design Patterns (Introduction)
│   ├── Creational Patterns → Singleton, Factory, Abstract Factory, Builder
│   ├── Structural Patterns → Adapter, Facade, Decorator, Composite
│   ├── Behavioral Patterns → Observer, Strategy, State, Command
│   └── SOLID principles foundation
│
├── Error Handling in OOP
│   ├── Exceptions in OOP context
│   ├── Custom exception classes
│   └── Resource cleanup in OOP systems
│
├── File Handling in OOP Design
│   ├── Data encapsulation in files
│   ├── Saving and restoring objects
│   └── Serialization & Deserialization (Pickle / JSON / Binary)
│
├── Memory & Performance in OOP
│   ├── Shallow vs deep copy
│   ├── Garbage collection & destructors
│   ├── Object pooling (concept)
│   └── Lazy loading
│
├── OOP in Databases & API Development
│   ├── ORM concept → mapping objects to tables
│   ├── Repositories & service classes
│   ├── DTOs & entity models
│   └── Layered architecture using OOP
│
├── Testing OOP Systems
│   ├── Unit testing methods & classes
│   ├── Mock objects
│   ├── Dependency injection for testing
│   └── TDD workflow in OOP
│
├── Anti-Patterns & Bad Practices
│   ├── God object
│   ├── Tight coupling
│   ├── Inappropriate inheritance
│   ├── Primitive obsession
│   ├── Circular dependencies
│   └── Misuse of static state
│
└── Real-World OOP Applications
    ├── Banking system
    ├── Hotel/Library/Inventory management system
    ├── Online shopping cart system
    ├── Ride booking / payment systems
    ├── Gaming (OOP game engines & characters)
    ├── Social media architecture components
    └── Scalable enterprise system design using OOP
```